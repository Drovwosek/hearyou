# Performance Test Scenarios

## Цели тестирования производительности

1. **Скорость обработки** - время от загрузки до результата
2. **Throughput** - количество одновременных запросов
3. **Надёжность** - стабильность под нагрузкой
4. **Ресурсы** - RAM, CPU, Disk usage

---

## PT-001: Baseline Performance (одиночный файл)

**Цель:** Установить базовые метрики для сравнения

**Тестовые файлы:**
- Small: 1 МБ, 1 минута аудио (MP3)
- Medium: 10 МБ, 10 минут аудио (MP3)
- Large: 50 МБ, 50 минут аудио (MP3)

**Метрики:**

| Размер | Загрузка | Конвертация | STT API | Post-proc | Итого |
|---|---|---|---|---|---|
| 1 МБ | ? | ? | ? | ? | **< 30s** |
| 10 МБ | ? | ? | ? | ? | **< 3min** |
| 50 МБ | ? | ? | ? | ? | **< 15min** |

**Как измерять:**
1. Запустить тест 5 раз для каждого размера
2. Вычислить среднее, медиану, min, max
3. Зафиксировать baseline в документации

**Пример команды:**
```bash
time curl -X POST http://92.51.36.233:8000/transcribe \
  -F "file=@test_1mb.mp3" \
  -F "punctuation=true"
# Затем poll /status/{task_id} до completion
```

**Критерии успеха:**
- 1 МБ обрабатывается < 30 секунд
- 10 МБ обрабатывается < 3 минут
- 50 МБ обрабатывается < 15 минут
- Вариативность < 20% между запусками

---

## PT-002: Concurrent Requests (параллельные запросы)

**Цель:** Проверить поведение при параллельной нагрузке

**Сценарии:**

### A. 3 параллельных запроса (max workers)
- 3 файла по 5 МБ
- Загружаются одновременно
- Все должны обрабатываться параллельно

**Ожидаемое поведение:**
- Все 3 в состоянии "processing"
- Время обработки ≈ baseline × 1.2 (небольшой overhead)
- Нет блокировок

### B. 10 параллельных запросов (очередь)
- 10 файлов по 2 МБ
- Первые 3 обрабатываются, остальные 7 в очереди

**Метрики:**
- Первые 3: time ≈ baseline
- Следующие 3: time ≈ baseline + queue_wait
- Общее время завершения всех 10
- RAM usage на пике

### C. 50 параллельных запросов (стресс)
- 50 файлов по 1 МБ
- Проверка стабильности очереди

**Критерии успеха:**
- Все 50 завершаются успешно
- Нет ошибок OOM (Out of Memory)
- Нет упавших воркеров
- Очередь работает корректно (FIFO)

**Тестовый скрипт:**
```bash
#!/bin/bash
for i in {1..50}; do
  curl -X POST http://92.51.36.233:8000/transcribe \
    -F "file=@test_1mb.mp3" &
  sleep 0.1
done
wait
```

---

## PT-003: Upload Speed (скорость загрузки)

**Цель:** Измерить реальную скорость загрузки

**Условия:**
- Тестировать с разных сетей:
  - Localhost (gigabit)
  - Local network (100 Mbit)
  - Internet (10 Mbit симулированный)
  - Mobile (4G симулированный)

**Метрики для 30 МБ файла:**

| Сеть | Скорость | Время загрузки | ETA точность |
|---|---|---|---|
| Localhost | ? MB/s | ? s | ? |
| 100 Mbit | ? MB/s | ? s | ? |
| 10 Mbit | ? MB/s | ? s | ? |
| 4G | ? MB/s | ? s | ? |

**Проверка chunked upload:**
- Файлы >10 МБ используют chunked
- Chunk size = 5 МБ
- Количество chunks = ceil(file_size / 5MB)
- Overhead на chunk assembly < 5%

---

## PT-004: Memory Usage

**Цель:** Убедиться что нет утечек памяти

**Тест:**
1. Записать baseline RAM usage (idle)
2. Загрузить 100 файлов последовательно
3. Дождаться обработки всех
4. Проверить RAM usage после

**Ожидаемый результат:**
- RAM usage возвращается к baseline ± 10%
- Нет постоянного роста (утечек)
- Временные файлы очищаются

**Команды мониторинга:**
```bash
# На сервере VPS
free -m
docker stats hearyou-stt
```

**Критерии:**
- Idle: ~50-100 МБ
- Processing 1 file: +50-100 МБ
- Processing 3 files: +150-300 МБ
- После cleanup: возврат к idle

---

## PT-005: Disk I/O

**Цель:** Проверить скорость чтения/записи

**Метрики:**
- Скорость записи чанков
- Скорость сборки файла из чанков
- Скорость ffmpeg конвертации

**Тест:**
1. Загрузить файл 100 МБ
2. Измерить время каждого этапа:
   - Upload chunks: X секунд
   - Assemble file: Y секунд
   - FFmpeg convert: Z секунд

**Оптимизация:**
- Использовать tmpfs для /app/chunks (RAM disk)
- Конвертация на лету во время сборки

---

## PT-006: Network Timeout Handling

**Цель:** Проверить resilience при сетевых проблемах

**Сценарии:**

### A. Медленная загрузка (100 KB/s)
- Симулировать медленную сеть
- Файл 10 МБ должен загрузиться за ~100 секунд
- Проверить что timeout не срабатывает

### B. Прерывание соединения
- Начать загрузку
- На 50% прервать соединение (kill curl)
- Проверить поведение сервера

**Ожидаемое:**
- Частичные чанки не мешают другим запросам
- Нет зависших воркеров
- Cleanup происходит корректно

---

## PT-007: Long Running Transcriptions

**Цель:** Тест очень длинных файлов

**Тестовый файл:**
- 2 часа аудио (~100 МБ)

**Проверки:**
- Загрузка завершается успешно
- Yandex API не таймаутит
- Результат корректный
- Нет обрывов соединения

**Примечание:** Yandex sync API ограничен 1 минутой, поэтому:
- Для >1 минуты нужен async API
- Или разбиение на части по 1 минуте

---

## PT-008: Rate Limit Performance

**Цель:** Убедиться что rate limiting не замедляет систему

**Тест:**
1. 10 запросов в течение 60 секунд (легитимные)
2. Измерить overhead от проверки rate limit

**Ожидаемый overhead:**
- < 5 мс на проверку
- Не блокирует обработку
- Корректно сбрасывается после 60 секунд

---

## PT-009: Cleanup Performance

**Цель:** Проверить скорость очистки старых файлов

**Сценарий:**
1. Создать 1000 старых файлов в /app/uploads, /app/results, /app/chunks
2. Вызвать DELETE /cleanup?days=7
3. Измерить время удаления

**Ожидаемое время:**
- 1000 файлов удаляются за < 10 секунд
- Нет блокировки основных операций

---

## Performance Benchmarks (целевые показатели)

### Response Time
- **P50 (медиана):** < 2 минуты для 10 МБ файла
- **P95:** < 5 минут для 10 МБ файла
- **P99:** < 10 минут для 10 МБ файла

### Throughput
- **Sustained:** 3 параллельных транскрибации
- **Peak queue:** до 20 задач в очереди без деградации

### Resource Usage
- **RAM:** < 500 МБ при 3 активных задачах
- **CPU:** < 80% average
- **Disk:** < 10 ГБ временных файлов

### Availability
- **Uptime:** 99.9% (< 45 минут downtime в месяц)
- **Error rate:** < 1% failed tasks
- **Timeout rate:** < 0.1%

---

## Load Testing Tools

### Рекомендуемые инструменты:

1. **Apache Bench (ab)**
```bash
ab -n 100 -c 10 -p test.mp3 http://92.51.36.233:8000/transcribe
```

2. **wrk** (HTTP benchmarking)
```bash
wrk -t4 -c10 -d30s --script=upload.lua http://92.51.36.233:8000/
```

3. **Locust** (Python load testing)
```python
from locust import HttpUser, task
class STTUser(HttpUser):
    @task
    def upload(self):
        files = {'file': open('test.mp3', 'rb')}
        self.client.post("/transcribe", files=files)
```

4. **Custom bash script** (простой вариант)
```bash
#!/bin/bash
# concurrent_test.sh
for i in {1..50}; do
  (
    curl -X POST http://92.51.36.233:8000/transcribe \
      -F "file=@test.mp3" \
      -w "\nTime: %{time_total}s\n"
  ) &
done
wait
```

---

## Monitoring во время тестов

**Команды для мониторинга:**
```bash
# CPU + RAM в реальном времени
ssh root@92.51.36.233 "top -b -n 1 | head -20"

# Docker stats
ssh root@92.51.36.233 "docker stats hearyou-stt --no-stream"

# Disk usage
ssh root@92.51.36.233 "df -h /app/uploads /app/chunks"

# Active tasks
curl -s http://92.51.36.233:8000/stats | jq

# Логи в реальном времени
curl -s "http://92.51.36.233:8000/logs?lines=20"
```

---

## Результаты должны быть задокументированы

После каждого performance теста записать:
- Дата и время теста
- Конфигурация (CPU cores, RAM, network)
- Результаты (время, throughput, ресурсы)
- Baseline сравнение (лучше/хуже чем предыдущий тест)
- Узкие места (bottlenecks)
- Рекомендации по оптимизации
